# -*- coding: utf-8 -*-
"""functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10cSfknJWfNzj0YIvcoMSj2QM5FN_Fls7
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
import scipy.stats as si

# interest rate
r=0.002


# loading data
def load_data(file_name):
  """
  Loading data from given file name
    
  Parameters
    file_name: name of the file to be loaded
  Return
    data: dataframe of stock prices and volatilities
    portfolio: dataframe of portfolio assets, positionsa and ect
  """
  all_data = pd.read_excel(file_name, index_col=0, header=1)

  data = all_data.iloc[:,:6]
  data.columns = ['IMPL VOL Apple', 'Price Apple', 'IMPL VOL Amazon', 'Price Amazon', 'IMPL VOL Google', 'Price Google']
  data['IMPL VOL Apple'] = data['IMPL VOL Apple']/100
  data['IMPL VOL Amazon'] = data['IMPL VOL Amazon']/100
  data['IMPL VOL Google'] = data['IMPL VOL Google']/100

  portfolio = all_data.iloc[:10, 12:]
  portfolio.reset_index(drop=True, inplace=True)
  portfolio_header = portfolio.iloc[0]
  portfolio = portfolio[1:]
  portfolio.columns = portfolio_header
  portfolio.reset_index(drop=True, inplace=True)
  
  return data, portfolio
  
  
def ml_greeks(stock_data, portfolio_data, r):
    """
    Creating normalized dataframe with stock prices, volatilities and Greeks
    
    Parameters:
        stock_data: dataframe of stock prices and volatilities
        portfolio_data: portfolio dataframe
        r: Riskfree interest rate
    Return:
        result: normalized dataframe of stock data and Greek parameters for each day
    """      
    all_greeks = []
    all_dates = []
    for date, row in stock_data.iterrows():
      greeks_list = portfolio_greeks(date=date, stock_data=stock_data, portfolio_data=portfolio_data, r=r)
      greeks_df = pd.DataFrame(greeks_list, columns=['Delta', 'Gamma', 'Theta', 'Vega', 'Rho'])
      greek_means = [greeks_df.Delta.mean(), greeks_df.Gamma.mean(), greeks_df.Theta.mean(), greeks_df.Vega.mean(), greeks_df.Rho.mean()]
      all_greeks.append(greek_means)
      all_dates.append(date)
      
    a = pd.DataFrame(all_greeks, columns=['Delta', 'Gamma', 'Theta', 'Vega', 'Rho'])
    a.insert(0, column='Date', value=all_dates)
    a.set_index('Date', inplace=True)
    
    ml_greeks = pd.concat((stock_data, a), axis=1, ignore_index=False)
    
    ml_greeks = (ml_greeks-ml_greeks.mean())/ml_greeks.std()
    
    portfolio_over_time = portfolio_values_over_time(stock_data=stock_data, portfolio_data=portfolio_data)
    ml_greeks['Value'] = portfolio_over_time.values
    
    return ml_greeks  
    

def plot_correlations(x, y, data, figsize):
    """
    Plots correlation maps between x and y
  
    Parameters
        x: list feature label
        y: target label
        data: dataframe with data of x and y
        figsize: figure size like (20,4)
    Output
        correlation plots between x and y
    """
    f, axes = plt.subplots(1,len(x), figsize=figsize)
      
    for i, value in enumerate(x):
        sns.regplot(x=value, y=y, data=data, ax=axes[i], )
        axes[i].set_title('{} correlation with {}'.format(value, y))
      
    plt.show()
    
  

# Black-Scholes method
def calc_value(S, K, T, r, sigma, option = 'Call'):
  """
  Calculating option values
    
  Parameters:
    S: Stock price
    K: Strike price
    T: Time to maturity
    r: Riskfree interest rate
    sigma: Volatility of underlying asset
  Return:
    result: option value
  """
  d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
  d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
  if option == 'Call':
    result = (S * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0))
  if option == 'Put':
    result = (K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0) - S * si.norm.cdf(-d1, 0.0, 1.0))
  
  return result
  
# Calculating Greek values 
def greeks(S, K, T, r, option, sigma):
  """
  Calculating Greeks of Black Schole model
  
  Parameters
    S: Stock price
    K: Strike price
    T: Time to maturity
    r: Riskfree interest rate
    sigma: Volatility of underlying asset
  Return:
    Delta: partial wrt S
    Gamma: second partial wrt S
    Theta: partial wrt T
    Vega: partial wrt v
    Rho: partial wrt r 
  """
  
  if option == 'Call':
    T_sqrt = np.sqrt(T)
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    Delta = si.norm.cdf(d1)
    Gamma = si.norm.pdf(d1) / (S * sigma * T_sqrt)
    Theta = -(S * sigma * si.norm.pdf(d1)) / (2 * T_sqrt) - r * K * np.exp( -r * T) * si.norm.cdf(d2)
    Vega = S * T_sqrt * si.norm.pdf(d1)
    Rho = K * T * np.exp(-r * T) * si.norm.cdf(d2)
    
  if option == 'Put':
    T_sqrt = np.sqrt(T)
    d1 = (np.log(S / K) + r * T) / (sigma * T_sqrt) + 0.5 * sigma * T_sqrt
    d2 = d1 - (sigma * T_sqrt)
    Delta = -si.norm.cdf(-d1)
    Gamma = si.norm.pdf(d1) / (S * sigma * T_sqrt)
    Theta = -(S * sigma * si.norm.pdf(d1)) / (2 * T_sqrt) + r * K * np.exp(-r * T) * si.norm.cdf(-d2)
    Vega = S * T_sqrt * si.norm.pdf(d1)
    Rho = -K * T * np.exp(-r * T) * si.norm.cdf(-d2)
  
  cache = (Delta, Gamma, Theta, Vega, Rho)
  
  return cache  

def get_row(date, df):
  """
  Selecting row of dataframe by date
  
  Parameters
    date: date in string
    df: given dataframe
  Return
    row of df where date==date
  """
  return df.loc[df.index==date]


def portfolio_value(date, stock_data, portfolio_data, r):
  """
  Calculating portfolio value at given day
  
  Parameters
    date: date on which portfolio value will be calculated
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: portfolio value at given day
  """  
  data_to_analyze = get_row(date=date, df=stock_data)
  value = 0
  for index, row in portfolio_data.iterrows():
    company = row['Company']
    share_price = data_to_analyze['Price {}'.format(company)].values[0]
    volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
    instrument = row['Instrument']
    position = row['Position']
    strike = row['Strike']
    if type(row['Tenor*']) == str:
      tenor = int(row['Tenor*'].split()[0])/12
      
    if instrument == 'Shares':
      value = value + position * share_price * (1-r)
    else:
      option_price = calc_value(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
      value = value + position * option_price
      
  return value


def portfolio_greeks(date, stock_data, portfolio_data, r):
  """
  Calculating Greek parameters for each option in portfolio at given day
  
  Parameters
    date: date on which Greek parameters will be calculated
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: list of Greek parameters for each options and 
    for shares Delta==1, Gamma==0, Theta==0, Vega==0, Rho==-0.01
  """
  greek_list = []
  data_to_analyze = get_row(date=date, df=stock_data)
  for index, row in portfolio_data.iterrows():
    company = row['Company']
    share_price = data_to_analyze['Price {}'.format(company)].values[0]
    volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
    instrument = row['Instrument']
    position = row['Position']
    strike = row['Strike']
    if type(row['Tenor*']) == str:
      tenor = int(row['Tenor*'].split()[0])/12
      
    if instrument == 'Shares':
      new_list = [1, 0, 0, 0, -0.01]
      greek_list.append(new_list)
    else:
      cache = greeks(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
      Delta, Gamma, Theta, Vega, Rho = cache
      new_list = [Delta, Gamma, Theta, Vega, Rho]
      greek_list.append(new_list)
      
  return greek_list
  
  
def test_VaR(portfolio_changes, vc_VaR):
    """
    Test if VaR model output performs acceptable
      
    Parameters
        portfolio_changes: list of changes of portfolio values
        vc_VaR: VaR 
    Prints total number of entries, number of entries with higher loss than VaR, fraction of entries with higher loss than VaR
    """
    num_examples = len(portfolio_changes)
    num_correct = 0
    for i in portfolio_changes:
        if i< vc_VaR:
          num_correct = num_correct + 1
    
    print('Total: {}'.format(num_examples))
    print('Correct: {}'.format(num_correct))
    print('Fraction: {}%'.format(np.round((num_correct/num_examples)*100),2))


def portfolio_values_over_time(stock_data, portfolio_data):
  """
  Calculating portfolio values over time
  
  Parameters
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: dataframe of portfolio values over time where date is index
      Columns
        'Value' - portfolio value 
  """
  values_dict = {}
  dates = stock_data.index
  for date in dates:
    data_to_analyze = get_row(date=date, df=stock_data)
    value = 0
    for index, row in portfolio_data.iterrows():
      company = row['Company']
      share_price = data_to_analyze['Price {}'.format(company)].values[0]
      volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
      instrument = row['Instrument']
      position = row['Position']
      strike = row['Strike']
      if type(row['Tenor*']) == str:
        tenor = int(row['Tenor*'].split()[0])/12

      if instrument == 'Shares':
        value = value + position * share_price
      else:
        option_price = calc_value(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
        value = value + position * option_price
        
    values_dict[date] = value
  values_df = pd.DataFrame.from_dict(values_dict, orient='index', columns=['Value'])
  
  return values_df

def calc_portfolio_changes(df):
  """
  Calculating percentage of how portfolio value changing over time
  
  Parameters
    df: dataframe of portfolio values over time where index are dates and values are in 'Values' column 
  Return
    portfolio_changes: list of changes of portfolio value in %
  """
  portfolio_changes = []
  for i, j in enumerate(df.values):
    if i != 0:
      diff = j[0] - df.values[i-1][0]
      change = (diff/j[0])*100
      portfolio_changes.append(change)
    else:
      portfolio_changes.append(0)
      
  return portfolio_changes


def var_historical(confident, df):
  """
  Calculating historical VaR value with confident as given
  
  Parameters
    confident: confident in %
    df: dataframe of portfolio values over time where index are dates and values are in 'Values column'
    
  Return
    VaR at given confident from historical data
  """
  
  diff = 100-confident
  portfolio_changes_sorted = calc_portfolio_changes(df)
  portfolio_changes_sorted.sort()
  count = len(portfolio_changes_sorted)
  index = int(count/100)*diff
  var = portfolio_changes_sorted[index]

  return var