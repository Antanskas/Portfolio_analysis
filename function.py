# -*- coding: utf-8 -*-
"""functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10cSfknJWfNzj0YIvcoMSj2QM5FN_Fls7
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
import scipy.stats as si

# interest rate
r=0.2


# loading data
def load_data(file_name):
  """
  Loading data from given file name
    
  Parameters
    file_name: name of the file to be loaded
  Return
    data: dataframe of stock prices and volatilities
    portfolio: dataframe of portfolio assets, positionsa and ect
  """
  all_data = pd.read_excel(file_name, index_col=0, header=1)

  data = all_data.iloc[:,:6]
  data.columns = ['IMPL VOL Apple', 'Price Apple', 'IMPL VOL Amazon', 'Price Amazon', 'IMPL VOL Google', 'Price Google']

  portfolio = all_data.iloc[:10, 12:]
  portfolio.reset_index(drop=True, inplace=True)
  portfolio_header = portfolio.iloc[0]
  portfolio = portfolio[1:]
  portfolio.columns = portfolio_header
  portfolio.reset_index(drop=True, inplace=True)
  
  return data, portfolio


# Black-Scholes method
def calc_value(S, K, T, r, sigma, option = 'Call'):
  """
  Calculating option values
    
  Parameters:
    S: Stock price
    K: Strike price
    T: Time to maturity
    r: Riskfree interest rate
    sigma: Volatility of underlying asset
  Return:
    result: option value
  """
  d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
  d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
  if option == 'Call':
    result = (S * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0))
  if option == 'Put':
    result = (K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0) - S * si.norm.cdf(-d1, 0.0, 1.0))
  
  return result
  
# Calculating Greek values 
def greeks(S, K, T, r, option, sigma):
  """
  Calculating Greeks of Black Schole model
  
  Parameters
    S: Stock price
    K: Strike price
    T: Time to maturity
    r: Riskfree interest rate
    sigma: Volatility of underlying asset
  Return:
    Delta: partial wrt S
    Gamma: second partial wrt S
    Theta: partial wrt T
    Vega: partial wrt v
    Rho: partial wrt r 
  """
  
  if option == 'Call':
    T_sqrt = np.sqrt(T)
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    Delta = si.norm.cdf(d1)
    Gamma = si.norm.pdf(d1) / (S * sigma * T_sqrt)
    Theta = -(S * sigma * si.norm.pdf(d1)) / (2 * T_sqrt) - r * K * np.exp( -r * T) * si.norm.cdf(d2)
    Vega = S * T_sqrt * si.norm.pdf(d1)
    Rho = K * T * np.exp(-r * T) * si.norm.cdf(d2)
    
  if option == 'Put':
    T_sqrt = np.sqrt(T)
    d1 = (np.log(S / K) + r * T) / (sigma * T_sqrt) + 0.5 * sigma * T_sqrt
    d2 = d1 - (sigma * T_sqrt)
    Delta = -si.norm.cdf(-d1)
    Gamma = si.norm.pdf(d1) / (S * sigma * T_sqrt)
    Theta = -(S * sigma * si.norm.pdf(d1)) / (2 * T_sqrt) + r * K * np.exp(-r * T) * si.norm.cdf(-d2)
    Vega = S * T_sqrt * si.norm.pdf(d1)
    Rho = -K * T * np.exp(-r * T) * si.norm.cdf(-d2)
  
  cache = (Delta, Gamma, Theta, Vega, Rho)
  
  return cache  

def get_row(date, df):
  """
  Selecting row of dataframe by date
  
  Parameters
    date: date in string
    df: given dataframe
  Return
    row of df where date==date
  """
  return df.loc[df.index==date]


def portfolio_value(date, stock_data, portfolio_data, r):
  """
  Calculating portfolio value at given day
  
  Parameters
    date: date on which portfolio value will be calculated
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: portfolio value at given day
  """  
  data_to_analyze = get_row(date=date, df=stock_data)
  value = 0
  for index, row in portfolio_data.iterrows():
    company = row['Company']
    share_price = data_to_analyze['Price {}'.format(company)].values[0]
    volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
    instrument = row['Instrument']
    position = row['Position']
    strike = row['Strike']
    if type(row['Tenor*']) == str:
      tenor = int(row['Tenor*'].split()[0])/12
      
    if instrument == 'Shares':
      value = value + position * share_price
    else:
      option_price = calc_value(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
      value = value + position * option_price
      
  return value


def portfolio_greeks(date, stock_data, portfolio_data, r):
  """
  Calculating Greek parameters for each option in portfolio at given day
  
  Parameters
    date: date on which Greek parameters will be calculated
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: list of Greek parameters for each options and 
    for shares Delta==1, Gamma==0, Theta==0, Vega==0, Rho==1
  """
  greek_list = []
  data_to_analyze = get_row(date=date, df=stock_data)
  for index, row in portfolio_data.iterrows():
    company = row['Company']
    share_price = data_to_analyze['Price {}'.format(company)].values[0]
    volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
    instrument = row['Instrument']
    position = row['Position']
    strike = row['Strike']
    if type(row['Tenor*']) == str:
      tenor = int(row['Tenor*'].split()[0])/12
      
    if instrument == 'Shares':
      new_list = [1, 0, 0, 0, 1]
      greek_list.append(new_list)
    else:
      cache = greeks(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
      Delta, Gamma, Theta, Vega, Rho = cache
      new_list = [Delta, Gamma, Theta, Vega, Rho]
      greek_list.append(new_list)
      
  return greek_list


def portfolio_values_over_time(stock_data, portfolio_data):
  """
  Calculating portfolio values over time
  
  Parameters
    stock_data: dataframe of stock prices and volatilities
    portfolio_data: portfolio dataframe
  Return
    value: dataframe of portfolio values over time where date is index
      Columns
        'Value' - portfolio value 
  """
  values_dict = {}
  dates = stock_data.index
  for date in dates:
    data_to_analyze = get_row(date=date, df=stock_data)
    value = 0
    for index, row in portfolio_data.iterrows():
      company = row['Company']
      share_price = data_to_analyze['Price {}'.format(company)].values[0]
      volatility = data_to_analyze['IMPL VOL {}'.format(company)].values[0]
      instrument = row['Instrument']
      position = row['Position']
      strike = row['Strike']
      if type(row['Tenor*']) == str:
        tenor = int(row['Tenor*'].split()[0])/12

      if instrument == 'Shares':
        value = value + position * share_price
      else:
        option_price = calc_value(S=share_price, K=strike, T=tenor, r=r, sigma=volatility, option=instrument)
        value = value + position * option_price
        
    values_dict[date] = value
  values_df = pd.DataFrame.from_dict(values_dict, orient='index', columns=['Value'])
  
  return values_df

def calc_portfolio_changes(df):
  """
  Calculating percentage of how portfolio value changing over time
  
  Parameters
    df: dataframe of portfolio values over time where index are dates and values are in 'Values' column 
  Return
    portfolio_changes: list of changes of portfolio value in %
  """
  portfolio_changes = []
  for i, j in enumerate(df.values):
    if i != 0:
      diff = j[0] - df.values[i-1][0]
      change = (diff/j[0])*100
      portfolio_changes.append(change)
    else:
      portfolio_changes.append(0)
      
  return portfolio_changes


def var_historical(confident, df):
  """
  Calculating historical VaR value with confident as given
  
  Parameters
    confident: confident in %
    df: dataframe of portfolio values over time where index are dates and values are in 'Values column'
    
  Return
    VaR at given confident from historical data
  """
  
  diff = 100-confident
  portfolio_changes_sorted = calc_portfolio_changes(df)
  portfolio_changes_sorted.sort()
  count = len(portfolio_changes_sorted)
  index = int(count/100)*diff
  var = portfolio_changes_sorted[index]

  return var